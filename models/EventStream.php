<?php

namespace app\models;

use Yii;
use yii\base\Model;
use app\models\EventItem;

/**
 * This is the model class for event streams.
 *
 * @property integer $id
 * @property string $uuid 
 * @property double $stopped_at timestamp in seconds with microseconds when the event stream has stopped. 
 * @property integer $lastEventId 
 * @property string $listenEvents the names of all the event that the streamer should listen on, comma separated.
 */
class EventStream extends EventItem
{

    /*
     * @event Event an event that is triggered when the stream has started in [[start()]].
     */
    const EVENT_STREAM_STARTED = 'streamStarted';
    /*
     * @event Event an event that is triggered when the stream has stopped in [[stop()]].
     */    
    const EVENT_STREAM_STOPPED = 'streamStopped';
    /*
     * @event Event an event that is triggered when the stream has resumed a previous instance in [[start()]].
     */
    const EVENT_STREAM_RESUMED = 'streamResumed';

    /*
     * @var resource the file descriptor resource holding the inotify instance.
     */
    private $_fd;
    /*
     * @var float timestamp in seconds with microseconds when the stream has started.
     */
    private $_startTime;
    /*
     * @var array an array holding all file stream resources to be watched for activity.
     */
    private $_read = [];
    /*
     * @var float|null timestamp in seconds with microseconds when the stream has resumed.
     */
    private $_resumeTime;
    /*
     * @var app\models\EventItem the event item last generated to calculate if an event was missed.
     */
    private $_lastEvent;
    /*
     * @var array An array holding all unique (inotify instance wide) watch descriptors for files watched
     * the event [[IN_CLOSE_WRITE]].
     */
    private $_fwd = [];
    /*
     * @var array An array holding all unique (inotify instance wide) watch descriptors for directories watched
     * the event [[IN_CREATE]].
     */
    private $_dwd = [];
    /*
     * @var array the names of all the event that the streamer should listen on.
     */
    private $_listenEvents = [];

    /*
     * @var integer defines the time in seconds how long the stream should run.
     */
    public $timeLimit = 120;
    /*
     * @var array Array containing all events generated by [[onEvent()]]. Each item is of type app\models\EventItem.
     */
    public $events = [];
    /*
     * @var integer number of event sent.
     */
    public $sentEvents;
    /*
     * @var integer maximum number of low priority events which should be sent in one seconds. Events exceeding 
     * this value will not be sent.
     */
    public $maxEventsPerSecond = 1;

    public $pathPrefixes;

    /**
     * @inheritdoc
     */
    public static function tableName()
    {
        return 'event_stream';
    }

    /**
     * @inheritdoc
     *
     * Initializes the inotify instance and its file descriptor, the stream is set to blocking mode
     * that we can listen on it later and wait until activity.
     */
    public function init()
    {

        $this->_startTime = microtime(true);

        $this->_fd = inotify_init();
        stream_set_blocking($this->_fd, true);

        array_push($this->_read, $this->_fd);

    }

    /*
     * Sets up the stream with the time limit and the needed headers. If the stream is resumed (the time limit
     * was exceeded and the client browser restarted the SSE stream) the fu nction will determine when the previous
     * stream stopped and raises the event [[EVENT_STREAM_RESUMED]] and sets [[resumeTime]] or, if not resumed, the
     * event [[EVENT_STREAM_Started]].
     * @return void
     */
    public function start(){

        set_time_limit($this->timeLimit + 1);
        ignore_user_abort(false);
        clearstatcache();

        header('Content-Type: text/event-stream');
        header('Cache-Control: no-cache');
        header("Connection: keep-alive");

        if(isset($this->stopped_at)){
            $this->_resumeTime = microtime(true);
            $this->_lastEvent = new EventItem([
                'generated_at' => $this->stopped_at,
                'id' => 0,
            ]);

            $this->trigger(self::EVENT_STREAM_RESUMED);
        }else{
            $this->_lastEvent = new EventItem([
                'generated_at' => microtime(true),
                'id' => 0,
            ]);

            $this->trigger(self::EVENT_STREAM_STARTED);
        }

    }

    /*
     * Stops the event stream and raises the [[EVENT_STREAM_STOPPED]] event. The db record is saved that
     * in the next invocation the stream can be resumed by the [[uuid]].
     * @return void
     */
    public function stop(){
        $this->stopped_at = microtime(true);
        $this->trigger(self::EVENT_STREAM_STOPPED);
        $this->save();
    }

    /**
     * @inheritdoc
     */
    public function rules()
    {
        return [
            [['uuid', 'listenEvents'], 'required'],
            [['stopped_at'], 'number'],
            [['uuid'], 'string', 'max' => 36],
        ];
    }

    /*
     * @return float amount of seconds which microseconds to stream from now on.
     */
    public function calcTimeout()
    {
        $sec =  $this->timeLimit - (microtime(true) - $this->_startTime);
        return $sec > 10 ? 10 : $sec;
    }

    /*
     * @return array Array which two elements; the first element contains the mount of seconds, the second 
     * element contains the amount of microseconds. Those two values together give the exact time from 
     * [[calcTimeout()]]. This is for the timeout value from the [[stream_select()]] function and is only 
     * needed there.
     */
    private function getTimeoutForSelect()
    {
        $exact = $this->calcTimeout();
        $seconds = floor($exact);
        $microseconds = floor(round(($exact-$seconds)*1000000));
        return [
            $seconds,
            $microseconds,
        ];
    }


    /*
     * The [[_listenEvents]] array is modified whether there is an event defined to listen on multiple
     * events/files.
     * @return void
     */
    private function setupWatches(){
        $this->refresh();
        $this->_listenEvents = explode(',', $this->listenEvents);
        $this->_listenEvents = preg_replace('/\:.*$/', '', $this->_listenEvents);
        $this->_listenEvents[] = 'event/' . $this->uuid;

        file_put_contents('/tmp/le', print_r($this->_listenEvents, true) . PHP_EOL, FILE_APPEND);

        foreach($this->_listenEvents as $event){
            if(basename($event) == "*"){
                $files = scandir('/tmp/user/' . dirname($event));
                foreach($files as $file){
                    if(is_file('/tmp/user/' . dirname($event) . '/' . $file)){
                        $this->_listenEvents[] = dirname($event) . '/' . $file;
                    }
                }
                $this->_listenEvents[] = dirname($event) . '/' . 'ALL';
            }
        }
        $this->_listenEvents = array_unique($this->_listenEvents);
    }

    /*
     * Calls [[setupWachtes()]] and sets up all the needed inotify watches. If the event file exists, 
     * an inotify watch is added for the [[IN_CLOSE_WRITE]] event. If the file does not exist, an event
     * [[IN_CREATE]] is added to the containing directory. If the directory itself does not exist too, an
     * event [[IN_CREATE]] to the directory one level up is set. This goes on until a directory exists,
     * event if it's "/". This function will not set multiple watches at the same directory or file. The
     * watch is only set if there is no watch on that item already.
     * The inotify watch descriptors are stored in the array [[_dwd]] for directories and [[_fwd]] for files.
     * @return integer the number of new inotify watches set.
     */
    private function addWatches(){
        $this->setupWatches();
        $watches = 0;
        foreach($this->_listenEvents as $event){
            $eventFile = '/tmp/user/' . $event;

            if(file_exists($eventFile)){
                if(!isset($this->_fwd[$event])){
                    $this->_fwd[$event] = inotify_add_watch($this->_fd, $eventFile, IN_CLOSE_WRITE);
                    $watches++;
                }
            }else{
                $dir = $eventFile;
                do {
                    $dir = dirname($dir);
                    if(file_exists($dir)){
                        if(!isset($this->_dwd[$dir])){
                            $this->_dwd[$dir] = inotify_add_watch($this->_fd, $dir, IN_CREATE);
                            $watches++;
                        }
                        break;
                    }
                } while(dirname($dir) != $dir);
            }
        }
        return $watches;
    }

    /*
     * Removes a watch and removes the element in the corresponding array.
     * @param integer $wd the inotify watch descriptor.
     * @return void
     */
    private function removeWatch($wd){
        @inotify_rm_watch($this->_fd, $wd);
        $event = array_search($wd, $this->_fwd);
        unset($this->_fwd[$event]);
        $event = array_search($wd, $this->_dwd);
        unset($this->_dwd[$event]);
    }

    /*
     * Removes all watches stored in the watch arrays [[_fwd]] and [[_dwd]].
     * @return void
     */
    private function removeWatches(){
        foreach($this->_fwd as $wd){
            $this->removeWatch($wd);
            //@inotify_rm_watch($this->_fd, $wd);
        }
        foreach($this->_dwd as $wd){
            $this->removeWatch($wd);
            //@inotify_rm_watch($this->_fd, $wd);
        }
    }

    /*
     * This function waits on all streams for an event and generates one or multiple event items.
     * 
     * The first job of this function is to determine if there are event missing. This can happen when the 
     * client browser restarted the event stream. This will take up to 5 seconds, depending on the connection
     * quality. In that time, events can occur. Also, if an event is generated at the excat time when an event 
     * is processed, another event can occur. All events are stored in the database, which is queried for 
     * such lost events. So, if [[_resumeTime]] and [[_lastEvent]] are set, we have to query the db for lost 
     * events. If not, or the db returns no record, we continue (or start) listening on the streams.
     * 
     * The function then blocks in the call of [[stream_select()]] until an event happend. If that's the case
     * the file now contains the event [[id]] of the db record. This is done by [[EventItem::generate()]]. The
     * db is queried and an [[EventItem]] is appended to the [[events]] array.
     * 
     * @return bool true means there was an event during a watch, false means the timeout was exceeded without
     * an event. This is usually the end of the stream.
     */
    public function onEvent(){
        while($this->calcTimeout() > 0){

            //needed by php to determine a connection abort by the user
            echo '0' . PHP_EOL . PHP_EOL; ob_flush(); flush();

            $this->addWatches();

            if($this->_resumeTime && isset($this->_lastEvent)){

                $this->events = EventItem::find()
                    ->where(['>', 'generated_at', $this->_lastEvent->generated_at])
                    ->andWhere(['>', 'id', $this->_lastEvent->id])
                    ->orderBy([ 'generated_at' => SORT_ASC ])->all();

                /*$query = EventItem::find()
                    ->where(['>', 'generated_at', $this->_lastEvent->generated_at])
                    ->andWhere(['>', 'id', $this->_lastEvent->id]);*/

                if(!empty($this->events)){
                    foreach($this->events as $event){
                        $event->sent_at = microtime(true);
                        $event->debug = YII_ENV_DEV ? json_encode([
                            'type' => 'lost event',
                            'delta' => microtime(true) - $event->generated_at
                        ]) : null;
                        $this->sentEvents++;
                    }

                    $this->_lastEvent = end($this->events);
                    return true;
                }
            }

            $r = $this->_read;
            $write = null;
            $except = null;

            $this->events = [];
            list($tv_sec, $tv_usec) = $this->getTimeoutForSelect();
            $this->_resumeTime = microtime(true);

            // wait for events
            if(stream_select($r, $write, $except, $tv_sec, $tv_usec) !== 0){

                foreach ($r as $socket) {

                    if (inotify_queue_len($socket) == 0) {
                        continue;
                    }

                    $events = inotify_read($socket);

                    //file written
                    if($events[0]['mask'] == IN_CLOSE_WRITE){

                        $event = array_search($events[0]['wd'], $this->_fwd);

                        //the event to reload the event list from the database:
                        if ($event == 'event/' . $this->uuid) {
                            $this->removeWatches();
                            continue 2;
                        }

                        $id = @file_get_contents('/tmp/user/' . $event);
                        if(is_numeric($id)){

                            if (isset($this->_lastEvent)) {
                                $this->events[0] = EventItem::find()
                                    ->where(['id' => $id])
                                    ->andWhere(['>', 'generated_at', $this->_lastEvent->generated_at])
                                    ->one();
                            }else{
                                $this->events[0] = EventItem::find()->where(['id' => $id])->one();
                            }

                            if($this->events[0] !== null){
                                $this->events[0]->sent_at = microtime(true);
                                $this->events[0]->debug = YII_ENV_DEV ? json_encode($events[0]) : null;
                                if($this->events[0]->priority != 0 || ($this->sentEvents/(microtime(true) - $this->_startTime)) < $this->maxEventsPerSecond){
                                    $this->sentEvents++;
                                    $this->_lastEvent = $this->events[0];
                                    return true;
                                }else{
                                    continue 2;
                                }
                            }
                        }

                        $this->removeWatch($events[0]['wd']);
                        $this->events[0] = new EventItem([
                            'event' => 'daemon/*',
                            'data' => json_encode([
                                'status' => 'stopped',
                                'item' => $event,
                                'source' => 'inotify'
                            ]),
                            'priority' => 0,
                            'concerns' => ['user' => 'ALL'],
                            'generated_at' => microtime(true),
                        ]);

                        $this->sentEvents++;
                        $this->_lastEvent = $this->events[0];
                        return true;


                    //new file/folder created
                    }else if($events[0]['mask'] == IN_CREATE){
                        $event = array_search($events[0]['wd'], $this->_dwd);

                        $this->events[0] = new EventItem([
                            'event' => basename($event) . '/*',
                            'data' => json_encode([
                                'status' => 'started',
                                'item' => basename($event) . '/' . $events[0]['name'],
                                'source' => 'inotify'
                            ]),
                            'priority' => 0,
                            'concerns' => ['user' => 'ALL'],
                            'generated_at' => microtime(true),
                        ]);

                        $this->sentEvents++;
                        $this->_lastEvent = $this->events[0];
                        return true;

                    //file removed
                    }else if($events[0]['mask'] == IN_IGNORED){
                        $this->removeWatch($events[0]['wd']);
                        continue 2;
                    }
                }
                $r = $this->_read;
            }

        }
        $this->removeWatches();
        fclose($this->_fd);
        return false;
    }
}
